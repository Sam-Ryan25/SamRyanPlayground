name: Release notes looped in

on:
  workflow_dispatch:
    inputs:
      days:
        description: "Number of days back to include releases"
        required: false
        default: "30"

jobs:
  publish:
    runs-on: ubuntu-latest

    steps:
      - name: Checkout repo
        uses: actions/checkout@v5

      - name: Set up Node.js
        uses: actions/setup-node@v6
        with:
          node-version: "20"

      - name: Install dependencies
        run: npm install axios openai

      - name: Collect, Clean, and Publish Notes to LoopedIn
        env:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
          OPENAI_API_KEY: ${{ secrets.OPENAI_API_KEY }}
          LOOPEDIN_API_KEY: ${{ secrets.LOOPEDIN_API_KEY }}
          LOOPEDIN_WORKSPACE_ID: ${{ secrets.LOOPEDIN_WORKSPACE_ID }}
          DAYS: ${{ github.event.inputs.days }}
        run: |
          node <<'EOF'
          const axios = require('axios');
          const OpenAI = require('openai');

          const days = parseInt(process.env.DAYS || "30", 10);
          const cutoff = new Date(Date.now() - days * 24 * 60 * 60 * 1000);
          const loopedinApiKey = process.env.LOOPEDIN_API_KEY;
          const workspaceId = process.env.LOOPEDIN_WORKSPACE_ID;

          async function run() {
            console.log("üì¶ Fetching GitHub releases...");
            console.log("Repository:", "${{ github.repository }}");
            console.log("Cutoff date:", cutoff.toISOString());

            const releases = await axios.get(
              "https://api.github.com/repos/${{ github.repository }}/releases",
              { headers: { Authorization: `token ${process.env.GITHUB_TOKEN}` } }
            );

            console.log("‚úÖ Total releases found:", releases.data.length);

            const recent = releases.data.filter(r => new Date(r.published_at) >= cutoff);
            console.log("‚úÖ Releases within cutoff:", recent.length);

            if (!recent.length) {
              console.log("‚ÑπÔ∏è No recent releases found in timeframe.");
              return;
            }

            const openai = new OpenAI({ apiKey: process.env.OPENAI_API_KEY });
            let combinedContent = "";

            for (const r of recent) {
              let content = r.body || "";
              console.log(`üß© Processing release: ${r.name || r.tag_name}`);

              // Clean release notes
              content = content.replace(/## What's Changed/g, '');
              content = content.replace(/## New Contributors[\s\S]*/g, '');
              content = content.replace(/Full Changelog:.*$/gm, '');
              content = content.replace(/ by @\S+/g, '');
              content = content.replace(/https:\/\/github\.com\/\S+/g, '');

              let lines = content.split('\n').map(l => l.trim()).filter(Boolean);
              console.log(`  ‚Ä¢ Lines after cleaning: ${lines.length}`);

              if (!lines.length) {
                console.log("  ‚ùå No valid lines, skipping release.");
                continue;
              }

              console.log("ü§ñ Sending to OpenAI...");
              const response = await openai.chat.completions.create({
                model: "gpt-4o-mini",
                messages: [
                  {
                    role: "system",
                    content: "You are a marketing assistant rewriting release note bullet points for end users. Keep them concise, friendly, and non-technical. Return one bullet per line, no markdown."
                  },
                  { role: "user", content: lines.join("\n") }
                ],
                temperature: 0.3,
                max_tokens: 1000,
              });

              console.log("‚úÖ OpenAI completed.");

              const cleaned = response.choices[0].message.content
                .split("\n")
                .map(l => l.trim())
                .filter(Boolean);

              console.log(`  ‚Ä¢ Cleaned bullets: ${cleaned.length}`);

              const section = `
                <h2>${r.name || r.tag_name} (${r.published_at.slice(0,10)})</h2>
                <ul>${cleaned.map(line => `<li>${line}</li>`).join('\n')}</ul>
              `;
              combinedContent += section + "\n";
            }

            console.log("üìù Final combined content length:", combinedContent.length);

            const title = `Release Notes (Last ${days} Days)`;
            console.log("üöÄ Sending to LoopedIn as draft...");
            console.log("Workspace:", workspaceId);

            try {
              const res = await axios.post(
                `https://api.loopedin.io/v1/workspaces/${workspaceId}/posts`,
                {
                  title,
                  content: combinedContent,
                  visibility: "public",
                  status: "draft"
                },
                {
                  headers: {
                    Authorization: `Bearer ${loopedinApiKey}`,
                    "Content-Type": "application/json",
                  },
                  validateStatus: () => true, // don't throw automatically
                }
              );

              console.log("üì° LoopedIn response status:", res.status);

              if (res.status >= 200 && res.status < 300) {
                console.log("‚úÖ Draft created successfully in LoopedIn!");
              } else {
                console.error("‚ùå LoopedIn returned an error:");
                console.error("Status:", res.status);
                console.error("Body:", res.data);
                process.exit(1);
              }
            } catch (err) {
              console.error("‚ùå Request failed before reaching LoopedIn API:");
              console.error(err);
              process.exit(1);
            }
          }

          run().catch(err => {
            console.error("‚ùå Uncaught failure:", err.response?.status, err.response?.data || err.message || err);
            process.exit(1);
          });
          EOF
